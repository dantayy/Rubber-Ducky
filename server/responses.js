// pull in the file system module
const fs = require('fs');

// vars for the html and css the client needs
const index = fs.readFileSync(`${__dirname}/../hosted/client.html`);
const issuePage = fs.readFileSync(`${__dirname}/../hosted/issues.html`);
const css = fs.readFileSync(`${__dirname}/../hosted/style.css`);
const clientJs = fs.readFileSync(`${__dirname}/../client/client.js`);
const jsBundle = fs.readFileSync(`${__dirname}/../hosted/bundle.js`);

// Issues object container and id var to be incremented when new issues are made
const issues = {};
let issueId = 0;

// for object to respond with when there are status messages/ids
const responseJSON = {};

// returns the base page for the client
const getIndex = (request, response) => {
    response.writeHead(200, { 'Content-Type': 'text/html' });
    response.write(index);
    response.end();
};

// returns the issue page for the client
const getIssuePage = (request, response) => {
    response.writeHead(200, { 'Content-Type': 'text/html' });
    response.write(issuePage);
    response.end();
};

// returns the specified css for the client
const getCSS = (request, response) => {
    response.writeHead(200, { 'Content-Type': 'text/css' });
    response.write(css);
    response.end();
};

// function for getting the client's js directly
const getClientJs = (request, response) => {
    response.writeHead(200, { 'Content-Type': 'application/javascript' });
    response.write(clientJs);
    response.end();
};

// added function to get our js file in our hosted folder.
// This js file is generated by babel build/run package.json.
// This ES5 file is created from the code in our ES6 file (in the client folder)
const getBundle = (request, response) => {
    response.writeHead(200, { 'Content-Type': 'application/javascript' });
    response.write(jsBundle);
    response.end();
};

// respond with json data
const respondJSON = (request, response, status, object) => {
    response.writeHead(status, { 'Content-Type': 'application/json' });
    response.write(JSON.stringify(object));
    response.end();
};

// respond only with headers
const respondJSONMeta = (request, response, status) => {
    response.writeHead(status, { 'Content-Type': 'application/json' });
    response.end();
};

// add an issue
const addIssue = (request, response, postParams) => {
    // start with failstate message and check for missing params first
    responseJSON.message = 'Need to type in an issue first!';
    if (!postParams.issue) {
        responseJSON.id = 'missingText';
        return respondJSON(request, response, 400, responseJSON);
    }

    // response code for new issue being created
    const responseCode = 201;
    // new issue object located at the index of the id
    issues[issueId] = {};
    // set the issue's parameters
    issues[issueId].id = issueId;
    issues[issueId].issue = postParams.issue;
    issues[issueId].quack = false;
    issues[issueId].comments = [];

    delete responseJSON.id;
    responseJSON.message = `Created Issue #${issueId}`;
    issueId++;
    return respondJSON(request, response, responseCode, responseJSON);
};

// add a comment to an issue
const addComment = (request, response, postParams, params) => {
    // check failstates first
    responseJSON.message = 'Need to type in an comment first!';
    if (!postParams.comment) {
        responseJSON.id = 'missingText';
        return respondJSON(request, response, 400, responseJSON);
    } else if (!params.id) {
        responseJSON.message = 'Need to specify which issue you\'re commenting on!';
        responseJSON.id = 'missingId';
        return respondJSON(request, response, 400, responseJSON);
    } else if (!issues[params.id]) {
        responseJSON.message = 'Specified issue does not exist';
        responseJSON.id = 'badId';
        return respondJSON(request, response, 400, responseJSON);
    }

    // update the issue's comment list with the submitted comment
    const responseCode = 204;
    issues[params.id].comments.push(postParams.comment);
    return respondJSONMeta(request, response, responseCode);
};

// return the issues list
const getIssues = (request, response, params) => {
    if (params.id && issues[params.id]) {
        const singleIssue = issues[params.id];
        return respondJSON(request, response, 200, { singleIssue });
    }
    return respondJSON(request, response, 200, { issues });
};

// send back notReal info
const notReal = (request, response) => {
    responseJSON.id = 'notFound';
    responseJSON.message = 'The page you are looking for was not found.';

    return respondJSON(request, response, 404, responseJSON);
};

// send back only the header data for a page that doesn't exist
const notRealMeta = (request, response) => respondJSONMeta(request, response, 404);

// export relevant functions
module.exports = {
    getIndex,
    getIssuePage,
    getCSS,
    getClientJs,
    getBundle,
    getIssues,
    notReal,
    notRealMeta,
    addIssue,
    addComment,
};
