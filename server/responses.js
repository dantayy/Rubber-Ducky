// pull in the file system module
const fs = require('fs');

// vars for the html, css, and js the client needs
const index = fs.readFileSync(`${__dirname}/../hosted/client.html`);
const notRealPage = fs.readFileSync(`${__dirname}/../hosted/notReal.html`);
const css = fs.readFileSync(`${__dirname}/../hosted/style.css`);
const jsBundle = fs.readFileSync(`${__dirname}/../hosted/bundle.js`);

// Issues object container and id var to be incremented when new issues are made
const issues = {};
let issueId = 0;

// object to respond with when there are status messages/ids
const responseJSON = {};

// returns the base page for the client
const getIndex = (request, response) => {
  response.writeHead(200, { 'Content-Type': 'text/html' });
  response.write(index);
  response.end();
};

// returns the specified css for the client
const getCSS = (request, response) => {
  response.writeHead(200, { 'Content-Type': 'text/css' });
  response.write(css);
  response.end();
};

// added function to get our js file in our hosted folder.
// This js file is generated by babel build/run package.json.
// This ES5 file is created from the code in our ES6 file (in the client folder)
const getBundle = (request, response) => {
  response.writeHead(200, { 'Content-Type': 'application/javascript' });
  response.write(jsBundle);
  response.end();
};

// respond with json data
const respondJSON = (request, response, status, object) => {
  response.writeHead(status, { 'Content-Type': 'application/json' });
  response.write(JSON.stringify(object));
  response.end();
};

// respond only with headers
const respondJSONMeta = (request, response, status) => {
  response.writeHead(status, { 'Content-Type': 'application/json' });
  response.end();
};

// add an issue
const addIssue = (request, response, postParams) => {
  // start with failstate message and check for missing params first
  responseJSON.message = 'Need to type in an issue first!';
  if (!postParams.issue) {
    responseJSON.id = 'missingText';
    return respondJSON(request, response, 400, responseJSON);
  }

  // new issue object located at the index of the id
  issues[issueId] = {};
  // set the issue's parameters
  issues[issueId].id = issueId;
  issues[issueId].issue = postParams.issue;
  issues[issueId].quack = false;
  issues[issueId].comments = [];

  delete responseJSON.id;
  responseJSON.message = `Created Issue #${issueId}`;
  issueId++;
  return respondJSON(request, response, 201, responseJSON);
};

// add a comment to an issue
const addComment = (request, response, postParams, params) => {
  // check failstates first
  responseJSON.message = 'Need to type in an comment first!';
  if (!postParams.comment) {
    responseJSON.id = 'missingText';
    return respondJSON(request, response, 400, responseJSON);
  } else if (!params.id) {
    responseJSON.message = 'Need to specify which issue you\'re commenting on!';
    responseJSON.id = 'missingId';
    return respondJSON(request, response, 400, responseJSON);
  } else if (!issues[params.id]) {
    responseJSON.message = 'Specified issue does not exist';
    responseJSON.id = 'badId';
    return respondJSON(request, response, 400, responseJSON);
  }

  // update the issue's comment list with the submitted comment
  issues[params.id].comments.push(postParams.comment);
  return respondJSONMeta(request, response, 204);
};

// return the issues list
const getIssues = (request, response, params) => {
  if (params.id && issues[params.id]) { // case of requesting a specific issue
    const singleIssue = issues[params.id];
    return respondJSON(request, response, 200, { singleIssue });
  }
  return respondJSON(request, response, 200, { issues });
};

// return meta info for an issues request
const getIssuesMeta = (request, response) => respondJSONMeta(request, response, 200);

// returns the 404 page for the client
const notReal = (request, response) => {
  response.writeHead(200, { 'Content-Type': 'text/html' });
  response.write(notRealPage);
  response.end();
};

// send back only the header data for a page that doesn't exist
const notRealMeta = (request, response) => respondJSONMeta(request, response, 404);

// export relevant functions
module.exports = {
  getIndex,
  getCSS,
  getBundle,
  getIssues,
  getIssuesMeta,
  notReal,
  notRealMeta,
  addIssue,
  addComment,
};
