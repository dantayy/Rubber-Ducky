// pull in the file system module
const fs = require('fs');
// querystring module for parsing querystrings from url
const query = require('querystring');

// vars for the html and css the client needs
const index = fs.readFileSync(`${__dirname}/../hosted/client.html`);
const css = fs.readFileSync(`${__dirname}/../hosted/style.css`);
const jsBundle = fs.readFileSync(`${__dirname}/../hosted/bundle.js`);

// Issues object container and id var to be incremented when new issues are made
const users = {};
const issues = {};
let issueId = 0;

// for object to respond with when there are status messages/ids
const responseJSON = {};

// returns the base page for the client
const getIndex = (request, response) => {
    response.writeHead(200, { 'Content-Type': 'text/html' });
    response.write(index);
    response.end();
};

// returns the specified css for the client
const getCSS = (request, response) => {
    response.writeHead(200, { 'Content-Type': 'text/css' });
    response.write(css);
    response.end();
};

//added function to get our js file in our hosted folder.
//This js file is generated by babel build/run package.json.
//This ES5 file is created from the code in our ES6 file (in the client folder)
const getBundle = (request, response) => {
    response.writeHead(200, { 'Content-Type': 'application/javascript' });
    response.write(jsBundle);
    response.end();
};

// respond with json data
const respondJSON = (request, response, status, object) => {
    console.log("Writing response with an obj");
    response.writeHead(status, { 'Content-Type': 'application/json' });
    response.write(JSON.stringify(object));
    response.end();
};

// respond only with headers
const respondJSONMeta = (request, response, status) => {
    console.log("Writing head data only");
    response.writeHead(status, { 'Content-Type': 'application/json' });
    response.end();
};

// handle a general post request
const handlePost = (request, response, parsedUrl) => {
    // vars for processing data sent to server for adding an issue
    const body = [];

    // .on calls are like event listeners triggering as the users data stream is being processed
    request.on('error', (err) => {
        console.log(err);
        response.statusCode = 400;
        response.end();
    });

    // process data
    request.on('data', (chunk) => {
        console.log("Processing data");
        body.push(chunk);
    });

    // make data processed easier to handle by putting the params into an obj
    request.on('end', () => {
        const bodyString = Buffer.concat(body).toString();
        return query.parse(bodyString);
    });
};

// add an issue
const addIssue = (request, response, postParams) => {
    // start with failstate message and check for missing params first
    responseJSON.message = 'Need to type in an issue first!';
    if (!postParams.issue) {
        responseJSON.id = 'missingText';
        return respondJSON(request, response, 400, responseJSON);
    }

    // response code for new issue being created
    let responseCode = 201;        
    // new issue object located at the index of the id
    issues[issueId] = {};
    // set the issue's parameters
    issues[issueId].id = issueId;
    issues[issueId].issue = postParams.issue;
    issues[issueId].quack = false;
    issues[issueId].comments = {};

    delete responseJSON.id;
    responseJSON.message = `Created Issue #${issueId}`;
    issueId++;
    return respondJSON(request, response, responseCode, responseJSON);
};

// add a comment to an issue
const addComment = (request, response, postParams, params) => {

    // check failstates first
    responseJSON.message = 'Need to type in an comment first!';
    if (!postParams.comment) {
        responseJSON.id = 'missingText';
        return respondJSON(request, response, 400, responseJSON);
    } else if (!params.id) {
        responseJSON.message = `Need to specify which issue you're commenting on!`;
        responseJSON.id = 'missingId';
        return respondJSON(request, response, 400, responseJSON);
    } else if (!issues[params.id]) {
        responseJSON.message = `Specified issue does not exist`;
        responseJSON.id = 'badId';
        return respondJSON(request, response, 400, responseJSON);
    }

    // update the issue's comment list with the submitted comment
    let responseCode = 204;
    issues[params.id].comments.push(postParams.comment);
    return respondJSONMeta(request, response, responseCode);
};

// return the issues list
const getIssues = (request, response, params) => {
    if(params.id && issues[params.id]){
        let singleIssue = issues[params.id];
        return respondJSON(request, response, 200, {singleIssue});
    }
    return respondJSON(request, response, 200, {issues});
};

// send back notReal info
const notReal = (request, response) => {
    responseJSON.id = 'notFound';
    responseJSON.message = 'The page you are looking for was not found.';

    return respondJSON(request, response, 404, responseJSON);
};

// send back only the header data for a page that doesn't exist
const notRealMeta = (request, response) => respondJSONMeta(request, response, 404);

//export relevant functions
module.exports = {
    getIndex,
    getCSS,
    getBundle,
    getIssues,
    notReal,
    notRealMeta,
    addIssue,
    addComment
};
